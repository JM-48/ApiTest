üü¶ INSTRUCCIONES PARA LA IA (para construir/modificar mi API ‚Äî versi√≥n final)

Quiero que modifiques o generes un proyecto en Spring Boot que cumpla con todos estos requisitos para una evaluaci√≥n acad√©mica. La API se desplegar√° en Render y usar√° PostgreSQL en producci√≥n. Adem√°s, los datos iniciales se cargar√°n desde archivos JSON que yo proporcionar√© (uno por entidad) al iniciar la app si la base de datos est√° vac√≠a.

üìå 1. Requisitos generales

La API debe:

permitir CRUD completo para Productos, Categor√≠as y (opcionalmente Clientes) ‚Äî seg√∫n instrucciones previas; en este trabajo actualmente sin clientes si ya lo acordamos

recibir y servir im√°genes

usar PostgreSQL como base de datos en ejecuci√≥n (no H2/Oracle/MySQL)

permitir poblar la BD desde archivos JSON ubicados en src/main/resources/datos/ (los JSON me los dar√° el usuario) ‚Äî el mecanismo debe ejecutar una carga inicial (seed) s√≥lo si las tablas est√°n vac√≠as

ser desplegable en Render sin configuraciones adicionales aparte de las variables de entorno

Cada entidad debe tener:

su modelo JPA (@Entity) ‚Äî porque vamos a persistir en PostgreSQL

su repositorio (JpaRepository)

su servicio con la l√≥gica de negocio

su controlador REST (@RestController)

(Nota: el uso de JPA es obligatorio aqu√≠ porque la persistencia en Postgres lo requiere.)

üìå 2. Persistencia y JSON de seed

Crear carpeta en el proyecto (incluida en el repo, no en runtime):

src/main/resources/datos/


Archivos que yo entregar√© (example names; la IA debe aceptar que los schemas pueden variar y adaptarlos en la fase final):

productos.json
categorias.json
ubicaciones.json
( clientes.json  ‚Äî opcional seg√∫n alcance )


Implementar una clase DataLoader o InicializadorDatos que:

En el arranque lea las tablas en la BD.

Si una tabla est√° vac√≠a, lea el JSON correspondiente con ObjectMapper (Jackson) y persista los registros en PostgreSQL (con repositorios JPA).

Registrar logs indicando cu√°ntos registros se cargaron.

Si los registros ya existen (por ejemplo, mismo id o nombre), evitar duplicados o aplicar upsert seg√∫n criterio (preferir evitar duplicados).

No usar los JSON como la fuente de verdad en runtime ‚Äî solo como seed/backup. Todas las operaciones CRUD deben afectar la BD.

üìå 3. Subida y acceso a im√°genes

Implementar endpoint para subir im√°genes:

POST /imagenes


Recibe MultipartFile imagen

Guarda el archivo en /uploads (ruta dentro del contenedor)

Genera nombre √∫nico (UUID + extensi√≥n)

Devuelve JSON con la URL p√∫blica:

{
  "url": "https://<mi-api>.onrender.com/imagenes/uuid.png"
}


Asegurar uploads se crea al iniciar si no existe.

En las entidades Producto almacenar imagenUrl (string) con esa URL.

Nota sobre Render: /uploads en Render no es persistente entre reinicios. Para evaluaci√≥n esto est√° OK. (Los datos permanentes estar√°n en Postgres.)

üìå 4. Endpoints necesarios (nombres en espa√±ol)
Categor√≠as
GET    /categorias
GET    /categorias/{id}
POST   /categorias
PUT    /categorias/{id}
DELETE /categorias/{id}

Productos
GET    /productos
GET    /productos/{id}
POST   /productos       (multipart/form-data si incluye imagen; o JSON con imageUrl)
PUT    /productos/{id}
DELETE /productos/{id}


POST /productos debe aceptar: nombre, descripcion, precio, categoriaId y imagen (archivo) o imagenBase64/imageUrl.

Ubicaciones (Regiones y Comunas)
GET /ubicaciones/regiones
GET /ubicaciones/regiones/{id}/comunas


Estas pueden venir del JSON ubicaciones.json (seed) y tambi√©n pueden almacenarse en Postgres, o mantenerse como recurso en memoria ‚Äî preferible persistir en BD para consistencia.

Im√°genes
POST /imagenes
GET  /imagenes/{archivo}

üìå 5. Modelos sugeridos (Java / JPA)
Categoria
@Entity
public class Categoria {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String nombre;
  // getters/setters
}

Producto
@Entity
public class Producto {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String nombre;
  private String descripcion;
  private double precio;
  @ManyToOne
  private Categoria categoria;
  private String imagenUrl;
  // getters/setters
}

Ubicacion y Comuna (opcional)
@Entity class Region { @Id Long id; String nombre; @OneToMany List<Comuna> comunas; }
@Entity class Comuna { @Id Long id; String nombre; @ManyToOne Region region; }


(La IA debe adaptar tipos/atributos si los JSON que entregue el usuario tienen otros nombres/formatos.)

üìå 6. Seed/Inicializaci√≥n (comportamiento esperado)

Clase InicializadorDatos (annotated @Component o @Service) con @EventListener(ApplicationReadyEvent.class) o @PostConstruct.

Para cada archivo JSON:

Si tabla vac√≠a, mapear JSON ‚Üí entidades ‚Üí saveAll() en su repositorio.

Loguear resultado.

Idempotencia: si el JSON tiene id pero la BD ya tiene registros, evitar duplicar; implementar l√≥gica simple: si tabla vac√≠a ‚Üí insertar; si no vac√≠a ‚Üí no tocar.

üìå 7. Swagger (OpenAPI)

A√±adir org.springdoc:springdoc-openapi-starter-webmvc-ui en pom.xml.

Documentaci√≥n disponible en:

/swagger-ui.html o /swagger-ui/index.html

üìå 8. Preparar para Render (application.properties / y variables)

src/main/resources/application.properties:

server.port=${PORT:8080}
spring.datasource.url=${JDBC_DATABASE_URL:${DATABASE_URL}}
spring.datasource.username=${DB_USER}
spring.datasource.password=${DB_PASS}
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true

spring.web.resources.static-locations=file:uploads/,classpath:/static/
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB


Variables de entorno que deber√° usar Render (documentarlas):

DATABASE_URL o JDBC_DATABASE_URL (usar la que Render provea)

DB_USER

DB_PASS

PORT (Render setea autom√°ticamente)

Aclaraci√≥n: Algunas veces Render proporciona una √∫nica DATABASE_URL en formato postgres://user:pass@host:port/db; la IA deber√° incluir utilidad para parsearla o usar la propiedad spring.datasource.url con la cadena correcta.

üìå 9. Estructura del proyecto sugerida (nombres en espa√±ol)
src/main/java/com/tuempresa/tiendaapi/
    controllers/
      CategoriaControlador.java
      ProductoControlador.java
      UbicacionControlador.java
      ImagenControlador.java
    services/
      CategoriaServicio.java
      ProductoServicio.java
      UbicacionServicio.java
      ImagenServicio.java
    models/
      Categoria.java
      Producto.java
      Region.java
      Comuna.java
    repositories/
      CategoriaRepositorio.java
      ProductoRepositorio.java
      RegionRepositorio.java
      ComunaRepositorio.java
    config/
      SwaggerConfig.java (opcional)
    InicializadorDatos.java
src/main/resources/datos/
    categorias.json
    productos.json
    ubicaciones.json
/uploads  (creada en runtime)

üìå 10. Buenas pr√°cticas exigidas a la IA

Validar IDs √∫nicos y relaciones (ej. producto.categoriaId debe existir)

Retornar errores claros en JSON (400, 404, 500)

Manejar transacciones m√≠nimas cuando corresponda

Logs informativos en la carga inicial y en errores

C√≥digo limpio y documentado

Tests b√°sicos (opcional pero recomendado)

üìå 11. Entregables esperados

La IA debe devolver:

Todos los archivos Java (controladores, servicios, repositorios, modelos, config).

pom.xml actualizado.

application.properties.

src/main/resources/datos/*.json (puede contener ejemplos; el usuario dar√° los archivos finales).

README.md con:

pasos para ejecutar local (mvn spring-boot:run)

c√≥mo crear la base de datos en Render y poner las env vars

c√≥mo desplegar en Render desde GitHub

c√≥mo usar Swagger y probar endpoints

Explicaci√≥n de c√≥mo la carga JSON ‚Üí Postgres funciona y c√≥mo reemplazar los JSON por otros que entregue el usuario.

ACLARACIONES IMPORTANTES ‚Äî LEE ANTES DE IMPLEMENTAR

Fuente de verdad: en tiempo de ejecuci√≥n la BD PostgreSQL es la fuente de verdad; los JSON son s√≥lo seed inicial.

Im√°genes: /uploads no es persistente en Render; si necesitas persistencia de im√°genes en producci√≥n, deber√≠as usar S3/Cloudinary (no obligatorio para evaluaci√≥n).

Formato de JSON: yo (usuario) te entregar√© los JSON con el formato final ‚Äî la IA deber√° adaptar los modelos si hay diferencias de campo/nombres.

Conexi√≥n a la BD de Render: la IA debe preparar el application.properties y la l√≥gica para leer DATABASE_URL/JDBC_DATABASE_URL y credenciales desde env vars.

Manejo de IDs: la BD generar√° IDs con IDENTITY; si los JSON iniciales traen ids, la IA puede insertarlos respetando esos ids o dejar que BD los reasigne; decide e indica el comportamiento en el README.